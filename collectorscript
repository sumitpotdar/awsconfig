import boto3
import json
import os
from datetime import datetime, timedelta
from decimal import Decimal
from botocore.exceptions import ClientError

# Environment variables
DYNAMODB_TABLE = os.environ.get('DYNAMODB_TABLE', 'RDSSecurityAudit')
ROLE_NAME = os.environ.get('CROSS_ACCOUNT_ROLE', 'RDSAuditRole')

# DynamoDB client
dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table(DYNAMODB_TABLE)

# Account configuration - Can be loaded from Parameter Store or DynamoDB
ACCOUNTS = [
    {'account_id': '243762578311', 'name': 'Sumit'}
    # {'account_id': '111111111111', 'name': 'Production'},
    # {'account_id': '222222222222', 'name': 'Development'},
    # {'account_id': '333333333333', 'name': 'Staging'},
]

def lambda_handler(event, context):
    """
    Main handler - Scans all RDS instances across multiple AWS accounts
    Runs daily via EventBridge scheduled rule
    """
    print(f"Starting RDS security audit at {datetime.now().isoformat()}")
    
    # Get current account ID
    sts = boto3.client('sts')
    current_account = sts.get_caller_identity()['Account']
    print(f"Running in account: {current_account}")
    
    scan_timestamp = datetime.now().isoformat()
    scan_date = datetime.now().strftime('%Y-%m-%d')
    total_instances = 0
    
    try:
        # Load accounts from Parameter Store if needed
        accounts = load_accounts_config()
        
        for account in accounts:
            account_id = account['account_id']
            account_name = account.get('name', account_id)
            
            print(f"\n=== Scanning Account: {account_name} ({account_id}) ===")
            
            try:
                # Check if this is the same account
                if account_id == current_account:
                    print(f"Scanning current account {account_name} - no role assumption needed")
                    credentials = None  # Use current credentials
                else:
                    # Assume role in target account
                    credentials = assume_role(account_id)
                
                # Scan all regions in this account
                instances = scan_account(account_id, account_name, credentials, scan_timestamp)
                
                # Store in DynamoDB
                store_instances(instances, scan_date, scan_timestamp)
                
                total_instances += len(instances)
                print(f"Found {len(instances)} instances in account {account_name}")
                
            except Exception as e:
                print(f"Error scanning account {account_id}: {str(e)}")
                # Continue with next account
                continue
        
        # Store scan metadata
        store_scan_metadata(scan_date, scan_timestamp, total_instances, len(accounts))
        
        print(f"\n=== Scan Complete ===")
        print(f"Total instances scanned: {total_instances}")
        print(f"Accounts scanned: {len(accounts)}")
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'message': 'Scan completed successfully',
                'scan_timestamp': scan_timestamp,
                'total_instances': total_instances,
                'accounts_scanned': len(accounts)
            })
        }
        
    except Exception as e:
        print(f"ERROR: {str(e)}")
        raise


def load_accounts_config():
    """Load account configuration from Parameter Store or use default"""
    try:
        ssm = boto3.client('ssm')
        response = ssm.get_parameter(
            Name='/rds-audit/accounts',
            WithDecryption=True
        )
        return json.loads(response['Parameter']['Value'])
    except:
        print("Using default account configuration")
        return ACCOUNTS


def assume_role(account_id):
    """Assume cross-account role and return credentials"""
    sts = boto3.client('sts')
    
    role_arn = f"arn:aws:iam::{account_id}:role/{ROLE_NAME}"
    
    try:
        response = sts.assume_role(
            RoleArn=role_arn,
            RoleSessionName=f"RDSAudit-{account_id}",
            DurationSeconds=3600
        )
        
        return response['Credentials']
        
    except ClientError as e:
        print(f"Failed to assume role in account {account_id}: {str(e)}")
        raise


def scan_account(account_id, account_name, credentials, scan_timestamp):
    """Scan all RDS instances in all regions for a given account"""
    instances = []
    
    # Create EC2 client to get regions
    if credentials:
        # Use assumed role credentials
        ec2 = boto3.client(
            'ec2',
            region_name='us-east-1',
            aws_access_key_id=credentials['AccessKeyId'],
            aws_secret_access_key=credentials['SecretAccessKey'],
            aws_session_token=credentials['SessionToken']
        )
    else:
        # Use current Lambda execution role (same account)
        ec2 = boto3.client('ec2', region_name='us-east-1')
    
    try:
        regions = [r['RegionName'] for r in ec2.describe_regions()['Regions']]
    except:
        regions = ['us-east-1', 'us-west-2', 'eu-west-1']
    
    for region in regions:
        try:
            # Create RDS client for this region
            if credentials:
                # Use assumed role credentials
                rds = boto3.client(
                    'rds',
                    region_name=region,
                    aws_access_key_id=credentials['AccessKeyId'],
                    aws_secret_access_key=credentials['SecretAccessKey'],
                    aws_session_token=credentials['SessionToken']
                )
            else:
                # Use current Lambda execution role (same account)
                rds = boto3.client('rds', region_name=region)
            
            # Get all RDS instances in this region
            paginator = rds.get_paginator('describe_db_instances')
            
            for page in paginator.paginate():
                for db in page['DBInstances']:
                    try:
                        instance_data = process_instance(
                            rds, db, account_id, account_name, region, scan_timestamp
                        )
                        instances.append(instance_data)
                        
                    except Exception as e:
                        print(f"Error processing instance {db.get('DBInstanceIdentifier')}: {str(e)}")
                        continue
                        
        except ClientError as e:
            error_code = e.response['Error']['Code']
            if error_code == 'UnauthorizedOperation':
                print(f"Not authorized for region {region}")
            else:
                print(f"Error in region {region}: {str(e)}")
            continue
            
    return instances


def process_instance(rds, db, account_id, account_name, region, scan_timestamp):
    """Process a single RDS instance and extract security data"""
    instance_id = db['DBInstanceIdentifier']
    db_arn = db['DBInstanceArn']
    
    # Get tags
    try:
        tags_response = rds.list_tags_for_resource(ResourceName=db_arn)
        tags = {tag['Key']: tag['Value'] for tag in tags_response['TagList']}
    except:
        tags = {}
    
    # Get SSL configuration
    ssl_info = get_ssl_configuration(rds, db)
    
    # Check Secrets Manager for password rotation
    secrets_info = check_secrets_manager(instance_id, region)
    
    # Build instance data
    instance_data = {
        'id': instance_id,
        'name': db.get('DBName') or instance_id,
        'engine': db['Engine'],
        'version': db['EngineVersion'],
        'status': db['DBInstanceStatus'],
        'region': region,
        'account_id': account_id,
        'account_name': account_name,
        'arn': db_arn,
        'tags': tags,
        'scan_timestamp': scan_timestamp,
        'encryption': {
            'atRest': db.get('StorageEncrypted', False),
            'inTransit': ssl_info['enabled'],
            'inTransitEnforced': ssl_info['enforced'],
            'certificateAuthority': ssl_info['ca_identifier'],
            'kmsKeyId': db.get('KmsKeyId')
        },
        'backups': {
            'automated': db.get('BackupRetentionPeriod', 0) > 0,
            'encrypted': db.get('StorageEncrypted', False),
            'retentionDays': db.get('BackupRetentionPeriod', 0)
        },
        'network': {
            'publiclyAccessible': db.get('PubliclyAccessible', False),
            'vpcId': db['DBSubnetGroup']['VpcId'] if db.get('DBSubnetGroup') else None,
            'securityGroups': [sg['VpcSecurityGroupId'] for sg in db.get('VpcSecurityGroups', [])]
        },
        'authentication': {
            'iamEnabled': db.get('IAMDatabaseAuthenticationEnabled', False),
            'passwordRotation': secrets_info['rotation_enabled'],
            'secretArn': secrets_info.get('secret_arn'),
            'lastRotated': secrets_info.get('last_rotated'),
            'rotationDays': secrets_info.get('rotation_days')
        },
        'monitoring': {
            'enhancedMonitoring': db.get('EnhancedMonitoringResourceArn') is not None,
            'performanceInsights': db.get('PerformanceInsightsEnabled', False)
        },
        'secrets': secrets_info  # Full secrets manager details
    }
    
    return instance_data


def get_ssl_configuration(rds, db):
    """Get SSL/TLS configuration"""
    ssl_info = {
        'enabled': False,
        'enforced': False,
        'ca_identifier': None
    }
    
    try:
        ca_cert = db.get('CACertificateIdentifier')
        if ca_cert:
            ssl_info['enabled'] = True
            ssl_info['ca_identifier'] = ca_cert
        
        if db.get('DBParameterGroups'):
            pg_name = db['DBParameterGroups'][0]['DBParameterGroupName']
            
            try:
                paginator = rds.get_paginator('describe_db_parameters')
                
                for page in paginator.paginate(DBParameterGroupName=pg_name):
                    for param in page.get('Parameters', []):
                        param_name = param.get('ParameterName', '')
                        param_value = param.get('ParameterValue', '')
                        
                        if param_name == 'rds.force_ssl' and param_value == '1':
                            ssl_info['enforced'] = True
                            break
                        elif param_name == 'require_secure_transport' and param_value == '1':
                            ssl_info['enforced'] = True
                            break
            except:
                pass
                
    except Exception as e:
        print(f"Error checking SSL: {str(e)}")
    
    return ssl_info


def store_instances(instances, scan_date, scan_timestamp):
    """Store instances in DynamoDB"""
    with table.batch_writer() as batch:
        for instance in instances:
            # Convert to DynamoDB format (handle Decimals)
            item = json.loads(json.dumps(instance), parse_float=Decimal)
            
            # Add DynamoDB keys
            item['PK'] = f"ACCOUNT#{instance['account_id']}"
            item['SK'] = f"INSTANCE#{instance['id']}#{scan_timestamp}"
            item['GSI1PK'] = f"DATE#{scan_date}"
            item['GSI1SK'] = f"ACCOUNT#{instance['account_id']}#INSTANCE#{instance['id']}"
            
            # Add TTL (keep data for 90 days)
            item['TTL'] = int((datetime.now() + timedelta(days=90)).timestamp())
            
            batch.put_item(Item=item)
    
    print(f"Stored {len(instances)} instances in DynamoDB")


def store_scan_metadata(scan_date, scan_timestamp, total_instances, accounts_scanned):
    """Store scan metadata"""
    item = {
        'PK': f"METADATA#{scan_date}",
        'SK': f"SCAN#{scan_timestamp}",
        'GSI1PK': 'METADATA',
        'GSI1SK': scan_timestamp,
        'scan_date': scan_date,
        'scan_timestamp': scan_timestamp,
        'total_instances': total_instances,
        'accounts_scanned': accounts_scanned,
        'TTL': int((datetime.now() + timedelta(days=90)).timestamp())
    }
    
    table.put_item(Item=item)
    print("Stored scan metadata")


def check_secrets_manager(instance_id, region):
    """
    Check AWS Secrets Manager for RDS credentials and rotation status
    Returns dict with rotation info
    """
    secrets_info = {
        'rotation_enabled': False,
        'secret_arn': None,
        'secret_name': None,
        'last_rotated': None,
        'rotation_days': None,
        'auto_rotation': False
    }
    
    try:
        # Create Secrets Manager client
        secretsmanager = boto3.client('secretsmanager', region_name=region)
        
        # List all secrets and find ones associated with this RDS instance
        paginator = secretsmanager.get_paginator('list_secrets')
        
        for page in paginator.paginate():
            for secret in page.get('SecretList', []):
                # Check if secret is tagged with this RDS instance
                # or if secret name contains the instance ID
                secret_name = secret.get('Name', '')
                tags = {tag['Key']: tag['Value'] for tag in secret.get('Tags', [])}
                
                # Check various ways secret might be linked to RDS
                is_rds_secret = False
                
                # Method 1: Check tags
                if tags.get('aws:rds:primaryDBInstanceArn'):
                    if instance_id in tags['aws:rds:primaryDBInstanceArn']:
                        is_rds_secret = True
                
                # Method 2: Check secret name contains instance ID
                if instance_id.lower() in secret_name.lower():
                    is_rds_secret = True
                
                # Method 3: Check description
                description = secret.get('Description', '')
                if instance_id in description:
                    is_rds_secret = True
                
                if is_rds_secret:
                    print(f"  Found secret: {secret_name}")
                    
                    secrets_info['secret_name'] = secret_name
                    secrets_info['secret_arn'] = secret.get('SecretArn')
                    
                    # Check rotation status
                    if secret.get('RotationEnabled'):
                        secrets_info['rotation_enabled'] = True
                        secrets_info['auto_rotation'] = True
                        
                        # Get rotation configuration
                        rotation_rules = secret.get('RotationRules', {})
                        secrets_info['rotation_days'] = rotation_rules.get('AutomaticallyAfterDays')
                    
                    # Get last rotated date
                    if secret.get('LastRotatedDate'):
                        secrets_info['last_rotated'] = secret['LastRotatedDate'].isoformat()
                    elif secret.get('LastChangedDate'):
                        secrets_info['last_rotated'] = secret['LastChangedDate'].isoformat()
                    
                    # Found the secret, break
                    break
        
        if secrets_info['secret_arn']:
            print(f"  Rotation enabled: {secrets_info['rotation_enabled']}")
            if secrets_info['rotation_days']:
                print(f"  Rotation interval: {secrets_info['rotation_days']} days")
        else:
            print(f"  No Secrets Manager secret found for {instance_id}")
            
    except Exception as e:
        print(f"  Error checking Secrets Manager: {str(e)}")
    
    return secrets_info